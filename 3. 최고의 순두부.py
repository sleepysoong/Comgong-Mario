"""
수환이는 순두부믈리에이다. 순두부믈리에란 최고 품질의 순두부를 찾아내기 위해 전 세계의 순두부를 맛보고 그 맛을 평가하는 일을 한다. 
매일 3끼를 순두부를 먹던 수환이는 갑자기 순두부가 너무 물려서 도저히 먹을 수가 없었다. 

수환이는 지난 21년간 맛본 순두부 중 가장 최고의 순두부를 찾아 마지막으로 먹어보고자 한다. 
수환이는 너무 많은 순두부를 먹어 가장 맛있는 순두부를 도저히 떠올릴 수가 없었다. 
다행이 수환이는 지금까지 먹은 모든 순두부의 맛을 기록해둔 수첩을 발견했다!


순두부의 맛은 다음과 같은 요소로 이루어져 있다. 
(고소함) (짭짤함) (시큼함)


수환이는 맛의 밸런스를 중요하게 생각하기 때문에 각 맛이 비슷하게 분포되어있는 순두부가 가장 맛있는 순두부라고 생각한다. 
맛의 밸런스가 똑같다면 맛의 세기가 더 강한 순두부를 더 맛있다고 생각한다. 
맛의 밸런스와 세기가 똑같다면 고소함, 짭짤함, 시큼함 순서대로 큰 맛을 더 선호한다. 
맛의 밸런스는 세 맛의 표준편차로, 맛의 세기는 세 맛의 평균으로 계산할 수 있다. 


예를 들어

맛이 10 10 10인 순두부와 10 10 11인 순두부를 비교하면 맛의 밸런스가 더 좋은 10 10 10 순두부가 더 맛있는 순두부이다. 
맛이 10 10 10인 순두부와 11 11 11인 순두부를 비교하면 맛의 밸런스는 똑같지만 맛의 세기가 더 강한 11 11 11 순두부를 선호한다. 
11 9 10 순두부와 11 10 9 순두부는 맛의 밸런스와 세기도 똑같지만 고소함이 같고 짭짤함이 더 큰 11 10 9 순두부를 더 선호한다. 


수환이가 맛본 순두부중 가장 맛있는 순두부를 찾아내는 함수를 만들어라. 
"""

import numpy

def getWinnerCandidates(data: dict, index: int) -> dict:
    maxValue = max(data[city][index] for city in data)
    for city, value in data.copy().items():
        """
        data.items()가 아닌 data.copy.items()를 사용한 이유:
        원본 객체를 이용하면 순환문을 도는 중에 딕셔너리가 수정되어 오류가 발생 함 --> 객체 복사로 해결
        """
        if value[index] != maxValue:
            del(data[city])
    return data

def sdb_melier(duboos: dict):
    data = {}
    for city, flavors in duboos.items():
        data[city] = (-numpy.std(flavors), numpy.mean(flavors), flavors[0], flavors[1])
        """
        다른 값들은 커야 맛있는 순두부일 가능성이 높지만, std는 작을 수록 맛있는 순두부일 가능성이 높음.
        하지만 로직을 통일하기 위해 부호를 음수로 변경함
        ----
        acidFlavor는 굳이 비교할 필요 없음
        (가장 맛있는 두부는 한 개라고 가정했기 때문에 acidFlavor까지 같을 수 없음)
        """
    i = 0
    while len(data) > 1:
        data = getWinnerCandidates(data, i)
        i += 1
        # 가장 맛있는 순두부는 1개라고 문제에서 줬기 때문에 i가 3을 넘는 경우는 생각하지 않음
    return list(data.keys())[0]

print(sdb_melier({'광주': (1, 1, 1), '서울':(10, 10, 11), '부산':(11, 11, 11), "부천":(12, 12, 12)}))